# Структура

Код реализации алгоритмов находится в [quicksort.c](./src/quicksort.c). В директории [test](./src/test) находятся тесты корректности и бенчмарк

# Запуск
Для распараллеливания используется библиотека [opencilk](https://www.opencilk.org/)

Если она у вас установлена, для запуска должно быть достаточно этого:
```shell
./build_and_run_test.sh
```
(Однако, важно заметить, что тогда для распараллеливания будут использоваться все доступные процессоры, а не 4, как требовалось в задании)

Если у вас не установлена opencilk или вы хотите запускать на 4х процессорах, то можно использовать Docker (я делал именно так, потому что не справился поставить себе opencilk)

Для этого необходимо иметь установленный Docker и скачать образ с официального сайта opencilk:
```shell
./load_opencilk_docker_image.sh
```
После чего для запуска тестов и бенчмарков достаточно запустить
```shell
./run.sh
```

В обоих случаях, соберутся два исполняемых файла: тест корректности и бенчмарк, и запустятся по очереди

# Выводы

## Результаты
Результаты запуска можно найти в [файле](./bench_results.txt)
В моём случае получилось такое: 
```
Parallel average time: 3624.00
Sequential average time: 11494.60
Parallel average time is 3.17 times lower than sequential
```
Т.е. ускорение в чуть больше трех раз

## Подробнее
Однако, такое получилось только используя алгоритм с плохой асимптотикой (распараллеливаем только запуски на меньшем и большем куске, перенос делаем полностью последовательно). Также был реализован алгоритм с использованием параллельного фильтра, на реализацию, замеры и мысли по этому поводу можно посмотреть в ветке full_par этого репозитория.
